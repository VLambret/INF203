\documentclass[10pt]{article}

\usepackage{graphics}
\usepackage{dirtree}
\usepackage{paracol}
\usepackage{epigraph}
\usepackage{enumitem}
\usepackage{xcolor}

\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

\setlength{\textwidth}{17cm}
\setlength{\oddsidemargin}{-1cm}
\setlength{\evensidemargin}{-1cm}
\setlength{\textheight}{26cm}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.3ex}

\input{preambule.tex}

\begin{document}
\thispagestyle{empty}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstdefinestyle{none}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=bash,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{black},
  commentstyle=\itshape\color{black},
  identifierstyle=\color{black},
  stringstyle=\color{black},
}

\lstset{tabsize=3, style=customc,literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}

\EnteteUE

\begin{center}
  {\large {\bf Corrigé TP9}}
\end{center}

\vspace*{0.5cm}

\begin{enumerate}[label=\textbf{[\alph*]}]
  \setlength\itemsep{1em}

\item La sortie obtenue pour l'exécution de \texttt{./arguments} est :

\begin{verbatim}
corentin@gazelle:GDB $ ./arguments
Erreur de segmentation (core dumped)
\end{verbatim}

\item D'après la trace d'exécution de gdb :

\begin{verbatim}
(gdb) run 17 42
Starting program: /home/corentin/w/uga/INF203/poly/Semaine9/TP9/GDB/arguments 17 42
Argument 1, valeur 17
Argument 2, valeur 42

Program received signal SIGSEGV, Segmentation fault.
0x08048451 in convertir (s=0x0) at arguments.c:10
10		while (s[i] != '\0') {
\end{verbatim}

On constate que l'erreur de segmentation est survenue dans la fonction
\texttt{convertir} alors que son argument \texttt{char * s} valait
\texttt{0x0}. \\

L'instruction \texttt{s[i]} de la ligne 10 correspond dans ce cas là à
un accès à la ième case du tableau à l'adresse \texttt{s} qui vaut
0, c'est à dire NULL. On comprend que l'on a tenté d'accéder à un
tableau qui n'existe pas !

\item Grâce aux commandes \texttt{up} et \texttt{print}, on comprends
  que la situation est la suivante :

  \begin{tabular}{|l|l|}
    \hline
    Nombre d'argument  & 2               \\ \hline
    argc               & 3               \\ \hline
    argv[0]            & ``./arguments'' \\ \hline
    argv[1]            & ``17''          \\ \hline
    argv[2]            & ``42''          \\ \hline
  \end{tabular}

  On voit dans la trace de gdb que l'on tente d'accéder à
  \texttt{argv[3]}. On comprends alors que la boucle qui appelle la
  fonction \texttt{convertir} pour chaque argument est mal paramétrée
  : son index \texttt{i} va de 1 à 3 alors qu'il devrait aller de 1 à
  2. Il faut donc corriger la condition de sortie de boucle du for
  comme cela :

\begin{verbatim}
  for (i=1; i<argc; i++) {
\end{verbatim}

\item On exécute simplement (sans argument) le programme
  \texttt{erreur}. On obtient l'erreur suivante :

\begin{verbatim}
corentin@gazelle:GDB $ ./erreur
Exception en point flottant (core dumped)
\end{verbatim}

(ou en anglais :  \texttt{floating point exception (core dumped)
  ./erreur}) \\

En exécutant le programme avec gdb, on apprend que l'erreur a eu lieu
dans le fichier \texttt{erreur.c} à la ligne 11 dans la fonction
\texttt{main} qui n'avait pas d'argument. La mention :
\texttt{Arithmetic exception} nous met sur la voie d'une erreur de
calcul. \\

Avec la commande \texttt{print} (racourcit ``p''), on constate qu'au
moment de l'exception, la valeur de \texttt{i} était de 1. En
regardant de plus près le fichier erreur.c, on constate alors les
choses suivantes :

\begin{itemize}
\item L'indentation du fichier est douteuse
\item Les variables q et r sont initialisée à l'aide d'une syntaxe à
  n'utiliser sous aucun prétexte
\item La ligne 11 effectue une division par zéro si i vaut 1
\end{itemize}

On comprends donc qu'il faut corriger la condition de sortie du for
pour que i aille de n à 1 au lieu de n à 0.

\item La différence entre la commande \texttt{print} et la commande
  \texttt{display} est que cette dernière affiche la variable à chaque
  commande gdb entrée ultérieurement. C'est donc très pratique pour
  suivre l'évolution d'une variable au cours du programme.

\item Explication des commandes \texttt{next} et \texttt{step} :
  \begin{description}
  \item[next] Exécute l'instruction et passe à la suivante. Passe ``au
    dessus'' des appels de fonction en exécutant toutes les
    instructions qu'elles contiennent.
  \item[step] Comme next, sauf si l'instruction est un appel de
    fonction. Dans ce cas, se place à la première instruction de
    celle-ci. On dit que gdb ``descend'' dans la fonction.
  \end{description}

\item La commande \texttt{cont}, pour ``continue'', reprend
  l'exécution normale du programme jusqu'au prochain breakpoint ou
  jusqu'à la fin du programme si aucun breakpoint n'est rencontré.

\item Tous les nombres de type $$2^n * 42$$ donnent $$x == 42$$ au
  bout d'un certain nombre d'itérations. Par exemple : \texttt{42},
  \texttt{84}, \texttt{168}.

\item On déclare la variable représentant la ligne découpée ainsi :

\begin{verbatim}
  char *ligne_courante_decoupee[TAILLE_MAX_LIGNE];
\end{verbatim}

On reconnait la même syntaxe que pour \texttt{argv} que nous
manipulons souvent : les crochets \texttt{[...]} signifient que nous
avons à faire à un tableau, et le type \texttt{char *} nous indique
qu'il s'agit d'un tableau de pointeurs vers un \texttt{char}, donc un
tableau de chaînes de caractère.

\item Une implémentation possible pour la fonction
  \texttt{decouper\_ligne} :

  \lstinputlisting[style=customc]{listing/decouper.c}

\item Il s'agit de rechercher une chaîne de caractères dans les
  fichiers .c et .h du répertoire courant. C'est bien évidemment la commande
  \texttt{grep} qui nous vient à l'esprit !

\begin{verbatim}
  grep executer *.c *.h
\end{verbatim}

La commande donne rapidement les fichiers et les numéros de ligne où
apparait le mot ``executer''. On voit que les occurrences
correspondent à la déclaration, l'implémentation et l'appel de la
fonction \texttt{executer\_ligne\_decoupee}.

\end{enumerate}
\end{document}
